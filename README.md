# 🎮 Dialogue Maker – Unity Integration

This Unity project is the **runtime companion** for the [Dialogue Maker (WPF App)](https://github.com/rezdevir/Dialogue-Maker).

It loads and manages dialogue data created by writers, displaying it inside Unity scenes while allowing programmers to trigger in-game events through **actions**.

---

## 🧩 Overview

The system reads dialogue data generated by the WPF tool (`.json` format) and connects it to characters, emotions, and actions inside Unity.

Each dialogue line can:

- Display text with styles (color, speed, size, etc.)
- Change emotions dynamically
- Trigger an **Action Prefab**
- Branch to new dialogue paths

---

## 📁 Folder Structure

All dialogue-related assets are stored under the `Resources` folder for runtime loading:

Assets/
└── Resources/
└── Dialogues/
├── JSONS/ ← Dialogue data (.json files from WPF app)
└── Characters/ ← Character folders and animations

---

## 💾 File & Folder Conventions

### 🗃️ Dialogue Files

WPF app exports dialogue in `.json` format.  
Place all exported files here:

Assets/Resources/Dialogues/JSONS/

Example:

Assets/Resources/Dialogues/JSONS/intro_scene.json

### 🧍 Speaker Folders

Each character has its own folder containing sprites, portraits, or animation references.

Path:

Assets/Resources/Dialogues/Characters/

Each folder name follows this convention:

talking-[speaker_name]-[emotion]

Example:

talking-clay-nothing
talking-floy-happy
talking-rez-confuse

This naming format lets the system automatically load the correct portrait or animation based on the current line’s **speaker** and **emotion**.

---

## ⚙️ Action System (Prefab-Based)

Actions allow dialogue lines to trigger gameplay events (e.g., unlock a door, play a sound, start a cutscene).

### 🔹 How It Works

1. Each action defined in the `.json` file (from WPF tool) matches a **Prefab** in Unity.
2. These prefabs must be placed in your `Resources` folder for runtime loading.
3. Each Action Prefab contains a **MonoBehaviour script** that includes a public function to be called when triggered.

---

### 🧱 Example Structure

Assets/Resources/Dialogues/Actions/
├── UnlockDoor.prefab
├── ShowNote.prefab
└── PlaySound.prefab

Each prefab should have a script with a callable method, e.g.:

```csharp
using UnityEngine;

public class UnlockDoorAction : MonoBehaviour
{
    public void StartAction()
    {
        // Your custom logic here
        Debug.Log("Door unlocked!");
        // Example: DoorController.Instance.Unlock();
    }
}

When the dialogue reaches a line containing:

[Action: UnlockDoor]

→ the system will load the prefab named UnlockDoor from Resources/Dialogues/Actions/
→ and automatically call its StartAction() method.
🧠 Integration Flow

    Writer: uses WPF Dialogue Maker to create .json file.

    Programmer: places that .json into Assets/Resources/Dialogues/JSONS/.

    System: automatically loads dialogues, links character portraits, and triggers action prefabs.

🔄 Example Runtime Flow

    The dialogue system loads intro_scene.json.

    The speaker is "clay", emotion "happy".
    → System loads the portrait from
    Assets/Resources/Dialogues/Characters/talking-clay-happy.

    The text line finishes and includes [Action: PlaySound].
    → System loads prefab PlaySound.prefab and calls its StartAction().

⚡ Notes & Tips

    Keep prefab names case-sensitive to match the action names exactly.

    Use consistent folder naming — the system depends on it.

    Always test your dialogue after importing a new .json file.

    Avoid renaming or moving JSON files after export unless you update references.

🧰 Dependencies

    Unity 2021.3+ (recommended)

    TextMeshPro (for dialogue rendering)

    JSON Utility or Newtonsoft.Json (for parsing dialogue data)

👤 Author

Reza – System Designer & Programmer
Focused on creating a unified workflow between writers and developers for faster, more flexible narrative systems in Unity.
```
